<!DOCTYPE html>
<html lang="ru">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta charset="UTF-8">
    <title>Репа-Киборг: Защитник Огорода</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #101010;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            image-rendering: pixelated;
            touch-action: none;
            overflow: hidden;
        }

        #gameContainer {
            background: #1a1a1a;
            position: relative;
            /* Для ПК - очень узкое изображение как на телефоне */
            width: 25vh;
            height: 100vh;
            max-width: 350px;
        }

        #gameCanvas {
            display: block;
            image-rendering: pixelated;
            cursor: pointer;
            width: 100%;
            height: 100%;
            object-fit: fill;
        }

        /* Только для мобильных устройств - растягиваем на весь экран */
        @media (max-width: 768px) {
            #gameContainer {
                width: 100vw !important;
                height: 100vh !important;
                max-width: none !important;
            }
        }

        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #FFB347;
            font-size: 19px;
            text-shadow: 2px 2px 0px #000;
            font-weight: bold;
            font-family: 'Courier New', monospace;
            display: none;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="ui">
            <div>ЛИСТЬЯ: <span id="leaves">9</span></div>
            <div>СЧЕТ: <span id="score">0</span></div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;

        // Фиксированные размеры канваса для всех устройств
        canvas.width = 400;
        canvas.height = 800;

        // Функция для определения типа устройства
        function isMobile() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                   window.innerWidth <= 768;
        }

        // Оптимизация для высоких герц и увеличенная скорость для всех
        const TARGET_FPS = 60;
        let lastTime = 0;
        let deltaTime = 0;
        const FRAME_TIME = 1000 / TARGET_FPS;
        
        const GAME_SPEED_MULTIPLIER = 2.5; // Высокая скорость для всех устройств

        // Функция вибрации для мобильных устройств
        function vibrate(duration = 50) {
            if (navigator.vibrate && isMobile()) {
                navigator.vibrate(duration);
            }
        }

        const scoreElement = document.getElementById('score');
        const leavesElement = document.getElementById('leaves');

        let gameState = {
            score: 0,
            leavesLeft: 9,
            gameRunning: false,
            time: 0,
            showMenu: false,
            isPaused: false,
            showStartButton: true
        };

        let mouseX = 0;
        let mouseY = 0;
        let touchStartX = 0;
        let touchCurrentX = 0;
        let isTouching = false;
        let lastTouchTime = 0;

        // Облака
        let clouds = [];
        for (let i = 0; i < 8; i++) {
            clouds.push({
                x: Math.random() * canvas.width,
                y: Math.random() * 150 + 20,
                speed: 0.2 + Math.random() * 0.3,
                size: 1 + Math.random() * 2
            });
        }

        // Солнце
        const sun = {
            x: canvas.width - 60,
            y: 80,
            rayFrame: 0
        };

        // Поверхность земли
        const groundLevel = canvas.height - 120;

        // Репа-киборг
        const turnip = {
            x: canvas.width / 2,
            y: groundLevel - 60,
            width: 36,
            height: 60,
            shootCooldown: 0,
            walkFrame: 0,
            isWalking: false,
            direction: 0
        };

        // Листья репы на поверхности
        let gardenLeaves = [];
        const centerX = canvas.width / 2;
        const spacing = 40; // Возвращаем оптимальное расстояние для 400px ширины
        for (let i = 0; i < 9; i++) {
            const offsetFromCenter = (i - 4) * spacing;
            gardenLeaves.push({
                x: centerX + offsetFromCenter,
                y: groundLevel,
                windFrame: Math.random() * 20,
                exists: true,
                beingTaken: false,
                takenBy: null
            });
        }

        // Дырки в земле
        let holes = [];

        // Обновляем количество листьев
        gameState.leavesLeft = gardenLeaves.length;

        let bullets = [];
        let birds = [];
        let particles = [];
        let fallingLeaves = [];
        let keys = {};

        // События мыши
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;

            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            handleClick(clickX * scaleX, clickY * scaleY);
        });

        function handleClick(clickX, clickY) {
            if (gameState.showStartButton) {
                if (clickX >= 100 && clickX <= 300 && clickY >= 500 && clickY <= 540) {
                    startNewGame();
                }
            } else if (gameState.gameRunning && !gameState.isPaused) {
                if (clickX >= 320 && clickX <= 390 && clickY >= 10 && clickY <= 35) {
                    gameState.isPaused = true;
                }
            } else if (gameState.isPaused) {
                if (clickX >= 120 && clickX <= 280 && clickY >= 400 && clickY <= 440) {
                    gameState.isPaused = false;
                }
            } else if (!gameState.gameRunning && !gameState.showStartButton) {
                if (clickX >= 140 && clickX <= 260 && clickY >= 600 && clickY <= 630) {
                    startNewGame();
                }
            }
        }

        function startNewGame() {
            gameState.showStartButton = false;
            gameState.gameRunning = true;
            gameState.isPaused = false;
            gameState.score = 0;
            gameState.leavesLeft = 9;
            gameState.time = 0;

            turnip.x = canvas.width / 2;
            turnip.y = groundLevel - 60;
            turnip.shootCooldown = 0;
            turnip.walkFrame = 0;
            turnip.isWalking = false;
            turnip.direction = 0;

            bullets = [];
            birds = [];
            particles = [];
            fallingLeaves = [];
            holes = [];

            gardenLeaves = [];
            const centerX = canvas.width / 2;
            const spacing = 40; // Соответствует начальным настройкам
            for (let i = 0; i < 9; i++) {
                const offsetFromCenter = (i - 4) * spacing;
                gardenLeaves.push({
                    x: centerX + offsetFromCenter,
                    y: groundLevel,
                    windFrame: Math.random() * 20,
                    exists: true,
                    beingTaken: false,
                    takenBy: null
                });
            }

            updateUI();
        }

        // События клавиатуры
        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        // Обработчики мыши
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            touchStartX = e.clientX - rect.left;
            touchCurrentX = touchStartX;
            isTouching = true;
            lastTouchTime = Date.now();

            const scaleX = canvas.width / rect.width;
            touchStartX *= scaleX;
            touchCurrentX *= scaleX;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isTouching) return;

            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            touchCurrentX = (e.clientX - rect.left) * scaleX;
        });

        canvas.addEventListener('mouseup', (e) => {
            isTouching = false;

            const touchDuration = Date.now() - lastTouchTime;
            const touchDistance = Math.abs(touchCurrentX - touchStartX);

            if (touchDuration < 300 && touchDistance < 20) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const clickX = touchStartX;
                const clickY = (e.clientY - rect.top) * scaleY;

                handleClick(clickX, clickY);
            }
        });

        // Обработчики касаний
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            touchStartX = touch.clientX - rect.left;
            touchCurrentX = touchStartX;
            isTouching = true;
            lastTouchTime = Date.now();

            const scaleX = canvas.width / rect.width;
            touchStartX *= scaleX;
            touchCurrentX *= scaleX;
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!isTouching) return;

            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            touchCurrentX = (touch.clientX - rect.left) * scaleX;
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            isTouching = false;

            const touchDuration = Date.now() - lastTouchTime;
            const touchDistance = Math.abs(touchCurrentX - touchStartX);

            if (touchDuration < 300 && touchDistance < 20) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const clickX = touchStartX;
                const clickY = (e.changedTouches[0].clientY - rect.top) * scaleY;

                handleClick(clickX, clickY);
            }
        }, { passive: false });

        function shoot() {
            const bullet = {
                x: turnip.x,
                y: turnip.y - 20,
                speed: 8 * GAME_SPEED_MULTIPLIER,
                angle: -Math.PI/2,
                radius: 3,
                trail: []
            };
            bullets.push(bullet);
            createMuzzleFlash();
        }

        function createMuzzleFlash() {
            for (let i = 0; i < 3; i++) {
                particles.push({
                    x: turnip.x,
                    y: turnip.y - 20,
                    vx: (Math.random() - 0.5) * 3,
                    vy: -Math.random() * 3,
                    life: 10,
                    maxLife: 10,
                    color: `hsl(${Math.random() * 60 + 20}, 100%, 60%)`
                });
            }
        }

        function createBird() {
            if (!gameState.gameRunning || gameState.leavesLeft <= 0 || gameState.isPaused) return;

            const availableLeaves = gardenLeaves.filter(leaf => leaf.exists && !leaf.beingTaken);
            if (availableLeaves.length === 0) return;

            const targetLeaf = availableLeaves[Math.floor(Math.random() * availableLeaves.length)];

            const bird = {
                x: Math.random() * canvas.width,
                y: -30,
                speed: (1 + Math.random()) * GAME_SPEED_MULTIPLIER,
                wingFrame: Math.random() * 20,
                state: 'flying',
                targetLeaf: targetLeaf,
                landingProgress: 0,
                hasLeaf: false,
                stealWholeRoot: Math.random() < 0.3
            };

            targetLeaf.beingTaken = true;
            targetLeaf.takenBy = bird;

            birds.push(bird);
        }

        function createExplosion(x, y, color) {
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * (2 + Math.random() * 2),
                    vy: Math.sin(angle) * (2 + Math.random() * 2),
                    life: 15,
                    maxLife: 15,
                    color: color
                });
            }
        }

        function createFallingLeaf(x, y, isWholeRoot = false) {
            fallingLeaves.push({
                x: x,
                y: y,
                vx: (Math.random() - 0.5) * 2,
                vy: Math.random() * 2 + 1,
                rotation: 0,
                rotSpeed: (Math.random() - 0.5) * 0.2,
                life: 60,
                isWholeRoot: isWholeRoot
            });
        }

        // Создание птиц с оптимизацией под высокие герцы
        setInterval(createBird, Math.floor(1500 / GAME_SPEED_MULTIPLIER));

        function update() {
            if (gameState.showStartButton) {
                gameState.time++;
                sun.rayFrame += 0.01;

                clouds.forEach(cloud => {
                    cloud.x += cloud.speed;
                    if (cloud.x > canvas.width + 40) {
                        cloud.x = -40;
                        cloud.y = Math.random() * 150 + 20;
                    }
                });

                gardenLeaves.forEach(leaf => {
                    if (leaf.exists) {
                        leaf.windFrame += 0.05;
                    }
                });
                return;
            }

            if (!gameState.gameRunning || gameState.isPaused) return;

            gameState.time++;
            sun.rayFrame += 0.01;

            // Автоматическая стрельба с фиксированной скоростью
            if (turnip.shootCooldown > 0) {
                turnip.shootCooldown--;
            } else {
                shoot();
                // Фиксированная скорость стрельбы с учетом FPS
                turnip.shootCooldown = Math.floor(25 / GAME_SPEED_MULTIPLIER);
            }

            // Движение репы с одинаковой скоростью на всех устройствах
            let moving = false;
            const moveSpeed = 3 * GAME_SPEED_MULTIPLIER;

            if (keys['a'] || keys['ф']) {
                turnip.x -= moveSpeed;
                turnip.direction = -1;
                moving = true;
            }
            if (keys['d'] || keys['в']) {
                turnip.x += moveSpeed;
                turnip.direction = 1;
                moving = true;
            }

            // Прямое следование за курсором/пальцем
            if (isTouching && gameState.gameRunning && !gameState.isPaused) {
                const targetX = touchCurrentX;
                const currentX = turnip.x;
                const difference = targetX - currentX;

                if (Math.abs(difference) > 5) {
                    if (difference < 0) {
                        turnip.direction = -1;
                    } else {
                        turnip.direction = 1;
                    }

                    // Одинаковая скорость следования для всех устройств
                    const speed = Math.min(Math.abs(difference) * 0.2, 8) * GAME_SPEED_MULTIPLIER;
                    turnip.x += Math.sign(difference) * speed;
                    moving = true;
                }
            }

            turnip.x = Math.max(30, Math.min(canvas.width - 30, turnip.x));

            if (moving) {
                turnip.walkFrame += 0.3;
                turnip.isWalking = true;
            } else {
                turnip.isWalking = false;
                turnip.walkFrame = 0;
                turnip.direction = 0;
            }

            clouds.forEach(cloud => {
                cloud.x += cloud.speed;
                if (cloud.x > canvas.width + 40) {
                    cloud.x = -40;
                    cloud.y = Math.random() * 150 + 20;
                }
            });

            gardenLeaves.forEach(leaf => {
                if (leaf.exists) {
                    leaf.windFrame += 0.05;
                }
            });

            // Пули с одинаковой скоростью на всех устройствах
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];

                bullet.x += Math.cos(bullet.angle) * bullet.speed;
                bullet.y += Math.sin(bullet.angle) * bullet.speed;

                if (bullet.x < 0 || bullet.x > canvas.width ||
                    bullet.y < 0 || bullet.y > canvas.height) {
                    bullets.splice(i, 1);
                }
            }

            // Птицы с одинаковой скоростью на всех устройствах
            for (let i = birds.length - 1; i >= 0; i--) {
                const bird = birds[i];
                bird.wingFrame += 0.4;

                switch (bird.state) {
                    case 'flying':
                        const dx = bird.targetLeaf.x - bird.x;
                        const dy = bird.targetLeaf.y - bird.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance > 15) {
                            bird.x += (dx / distance) * bird.speed;
                            bird.y += (dy / distance) * bird.speed;
                        } else {
                            bird.state = 'landing';
                        }
                        break;

                    case 'landing':
                        bird.landingProgress++;
                        if (bird.landingProgress > 30) {
                            bird.state = 'taking';
                            bird.landingProgress = 0;
                        }
                        break;

                    case 'taking':
                        bird.landingProgress++;
                        if (bird.landingProgress > 10) {
                            holes.push({
                                x: bird.targetLeaf.x,
                                y: bird.targetLeaf.y
                            });

                            bird.targetLeaf.exists = false;
                            bird.hasLeaf = true;
                            bird.hasWholeRoot = true;
                            bird.state = 'escaping';
                            gameState.leavesLeft--;
                            updateUI();
                        }
                        break;

                    case 'escaping':
                        bird.y -= bird.speed * 2;
                        if (bird.y < -50) {
                            birds.splice(i, 1);
                            continue;
                        }
                        break;
                }

                if (bird.y > canvas.height + 50) {
                    if (bird.targetLeaf) {
                        bird.targetLeaf.beingTaken = false;
                        bird.targetLeaf.takenBy = null;
                    }
                    birds.splice(i, 1);
                }
            }

            for (let i = fallingLeaves.length - 1; i >= 0; i--) {
                const leaf = fallingLeaves[i];
                leaf.x += leaf.vx;
                leaf.y += leaf.vy;
                leaf.rotation += leaf.rotSpeed;
                leaf.vy += 0.1;
                leaf.life--;

                if (leaf.life <= 0 || leaf.y > canvas.height) {
                    fallingLeaves.splice(i, 1);
                }
            }

            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vx *= 0.95;
                p.vy *= 0.95;
                p.life--;

                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }

            // Проверка столкновений с вибрацией при попадании
            for (let i = bullets.length - 1; i >= 0; i--) {
                for (let j = birds.length - 1; j >= 0; j--) {
                    const bullet = bullets[i];
                    const bird = birds[j];

                    if (!bullet || !bird) continue;

                    const distance = Math.sqrt(
                        (bullet.x - bird.x) ** 2 + (bullet.y - bird.y) ** 2
                    );

                    if (distance < bullet.radius + 16) {
                        // Вибрация при попадании (только на мобильных)
                        vibrate(50);

                        createExplosion(bird.x, bird.y, '#8B4513');

                        if (bird.hasLeaf && bird.hasWholeRoot) {
                            createFallingLeaf(bird.x, bird.y, true);
                        }

                        if (bird.targetLeaf) {
                            bird.targetLeaf.beingTaken = false;
                            bird.targetLeaf.takenBy = null;
                        }

                        gameState.score += 20;
                        bullets.splice(i, 1);
                        birds.splice(j, 1);
                        updateUI();
                        break;
                    }
                }
            }

            if (gameState.leavesLeft <= 0) {
                gameState.gameRunning = false;
            }
        }

        function drawPixelText(text, x, y, color = '#FFFFFF', size = 1) {
            const charWidth = 6 * size;
            const charHeight = 8 * size;

            ctx.fillStyle = color;

            const pixelChars = {
                'А': [[0,1,1,1,0],[1,0,0,0,1],[1,1,1,1,1],[1,0,0,0,1],[1,0,0,0,1]],
                'Б': [[1,1,1,1,0],[1,0,0,0,1],[1,1,1,1,0],[1,0,0,0,1],[1,1,1,1,0]],
                'В': [[1,1,1,1,0],[1,0,0,0,1],[1,1,1,1,0],[1,0,0,0,1],[1,1,1,1,0]],
                'Г': [[1,1,1,1,1],[1,0,0,0,0],[1,1,1,0,0],[1,0,0,0,0],[1,0,0,0,0]],
                'Д': [[0,1,1,1,0],[0,1,0,1,0],[0,1,0,1,0],[1,1,0,1,1],[1,1,1,1,1]],
                'Е': [[1,1,1,1,1],[1,0,0,0,0],[1,1,1,1,0],[1,0,0,0,0],[1,1,1,1,1]],
                'Ж': [[1,0,1,0,1],[1,0,1,0,1],[0,1,1,1,0],[1,0,1,0,1],[1,0,1,0,1]],
                'З': [[1,1,1,1,0],[0,0,0,0,1],[0,1,1,1,0],[0,0,0,0,1],[1,1,1,1,0]],
                'И': [[1,0,0,0,1],[1,0,0,1,1],[1,0,1,0,1],[1,1,0,0,1],[1,0,0,0,1]],
                'К': [[1,0,0,1,0],[1,0,1,0,0],[1,1,0,0,0],[1,0,1,0,0],[1,0,0,1,0]],
                'Л': [[0,1,1,1,1],[0,0,1,0,1],[0,0,1,0,1],[0,0,1,0,1],[1,0,1,0,1]],
                'М': [[1,0,0,0,1],[1,1,0,1,1],[1,0,1,0,1],[1,0,0,0,1],[1,0,0,0,1]],
                'Н': [[1,0,0,0,1],[1,0,0,0,1],[1,1,1,1,1],[1,0,0,0,1],[1,0,0,0,1]],
                'О': [[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0]],
                'П': [[1,1,1,1,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1]],
                'Р': [[1,1,1,1,0],[1,0,0,0,1],[1,1,1,1,0],[1,0,0,0,0],[1,0,0,0,0]],
                'С': [[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,0],[1,0,0,0,1],[0,1,1,1,0]],
                'Т': [[1,1,1,1,1],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0]],
                'У': [[1,0,0,0,1],[1,0,0,0,1],[0,1,0,1,0],[0,0,1,0,0],[0,0,1,0,0]],
                'Ф': [[0,1,1,1,0],[1,0,1,0,1],[1,1,1,1,1],[1,0,1,0,1],[0,1,1,1,0]],
                'Х': [[1,0,0,0,1],[0,1,0,1,0],[0,0,1,0,0],[0,1,0,1,0],[1,0,0,0,1]],
                'Ц': [[1,0,0,1,0],[1,0,0,1,0],[1,0,0,1,0],[1,1,1,1,1],[0,0,0,1,0]],
                'Ч': [[1,0,0,0,1],[1,0,0,0,1],[0,1,1,1,1],[0,0,0,0,1],[0,0,0,0,1]],
                'Ш': [[1,0,1,0,1],[1,0,1,0,1],[1,0,1,0,1],[1,0,1,0,1],[1,1,1,1,1]],
                'Щ': [[1,0,1,0,1],[1,0,1,0,1],[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,1]],
                'Ъ': [[1,1,0,0,0],[0,1,0,0,0],[0,1,1,1,0],[0,1,0,0,1],[0,1,1,1,0]],
                'Ы': [[1,0,0,0,1],[1,0,1,0,1],[1,1,0,0,1],[1,0,1,0,1],[1,0,0,0,1]],
                'Ь': [[1,0,0,0,0],[1,0,0,0,0],[1,1,1,1,0],[1,0,0,0,1],[1,1,1,1,0]],
                'Э': [[0,1,1,1,0],[1,0,0,0,1],[0,0,1,1,0],[1,0,0,0,1],[0,1,1,1,0]],
                'Ю': [[1,0,1,1,0],[1,0,1,0,1],[1,1,1,0,1],[1,0,1,0,1],[1,0,1,1,0]],
                'Я': [[0,1,1,1,1],[1,0,0,0,1],[0,1,1,1,1],[0,0,1,0,1],[0,0,0,0,1]],
                ' ': [[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]],
                '0': [[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0]],
                '1': [[0,0,1,0,0],[0,1,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,1,1,1,0]],
                '2': [[0,1,1,1,0],[1,0,0,0,1],[0,0,1,1,0],[0,1,0,0,0],[1,1,1,1,1]],
                '3': [[0,1,1,1,0],[1,0,0,0,1],[0,0,1,1,0],[1,0,0,0,1],[0,1,1,1,0]],
                '4': [[1,0,0,1,0],[1,0,0,1,0],[1,1,1,1,1],[0,0,0,1,0],[0,0,0,1,0]],
                '5': [[1,1,1,1,1],[1,0,0,0,0],[1,1,1,1,0],[0,0,0,0,1],[1,1,1,1,0]],
                '6': [[0,1,1,1,0],[1,0,0,0,0],[1,1,1,1,0],[1,0,0,0,1],[0,1,1,1,0]],
                '7': [[1,1,1,1,1],[0,0,0,1,0],[0,0,1,0,0],[0,1,0,0,0],[1,0,0,0,0]],
                '8': [[0,1,1,1,0],[1,0,0,0,1],[0,1,1,1,0],[1,0,0,0,1],[0,1,1,1,0]],
                '9': [[0,1,1,1,0],[1,0,0,0,1],[0,1,1,1,1],[0,0,0,0,1],[0,1,1,1,0]],
                ':': [[0,0,0,0,0],[0,0,1,0,0],[0,0,0,0,0],[0,0,1,0,0],[0,0,0,0,0]]
            };

            for (let i = 0; i < text.length; i++) {
                const char = text[i].toUpperCase();
                const pattern = pixelChars[char];
                if (pattern) {
                    for (let row = 0; row < 5; row++) {
                        for (let col = 0; col < 5; col++) {
                            if (pattern[row][col]) {
                                drawPixelRect(x + i * charWidth + col * size, y + row * size, size, size);
                            }
                        }
                    }
                }
            }
        }

        function drawPauseButton() {
            drawPixelText('ПАУЗА', 320, 18, '#FFB347', 2);
        }

        function drawPauseScreen() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            drawPixelText('ПАУЗА', 150, 300, '#FFB347', 3);
            drawPixelText('ПРОДОЛЖИТЬ', 120, 410, '#FFB347', 2);
        }

        function drawSky() {
            const gradient = ctx.createLinearGradient(0, 0, 0, groundLevel);
            gradient.addColorStop(0, '#1E90FF');
            gradient.addColorStop(0.4, '#6495ED');
            gradient.addColorStop(0.8, '#87CEEB');
            gradient.addColorStop(1, '#B0C4DE');

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, groundLevel);

            ctx.fillStyle = '#FFD700';
            drawPixelCircle(sun.x, sun.y, 32);

            ctx.fillStyle = '#FFFF00';
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2 + sun.rayFrame;
                const rayLength = 50 + Math.sin(sun.rayFrame * 3 + i) * 6;
                const rayX = sun.x + Math.cos(angle) * rayLength;
                const rayY = sun.y + Math.sin(angle) * rayLength;
                drawPixelRect(rayX - 2, rayY - 2, 6, 6);
            }

            clouds.forEach(cloud => {
                ctx.fillStyle = 'white';
                const size = cloud.size;

                drawPixelRect(cloud.x - 10 * size, cloud.y, 20 * size, 8 * size);
                drawPixelRect(cloud.x - 8 * size, cloud.y - 4 * size, 16 * size, 8 * size);
                drawPixelRect(cloud.x - 6 * size, cloud.y - 6 * size, 12 * size, 6 * size);
                drawPixelRect(cloud.x - 12 * size, cloud.y + 2 * size, 8 * size, 6 * size);
                drawPixelRect(cloud.x + 4 * size, cloud.y + 2 * size, 8 * size, 6 * size);

                ctx.fillStyle = 'rgba(200, 200, 200, 0.7)';
                drawPixelRect(cloud.x - 8 * size, cloud.y + 6 * size, 16 * size, 2 * size);
            });
        }

        function drawGround() {
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(0, groundLevel, canvas.width, canvas.height - groundLevel);

            ctx.fillStyle = '#A0522D';
            for (let x = 0; x < canvas.width; x += 16) {
                for (let y = groundLevel + 8; y < canvas.height; y += 16) {
                    drawPixelRect(x + 2, y + 2, 3, 3);
                    drawPixelRect(x + 8, y + 6, 2, 2);
                }
            }

            ctx.fillStyle = '#654321';
            for (let x = 5; x < canvas.width; x += 20) {
                for (let y = groundLevel + 12; y < canvas.height; y += 20) {
                    drawPixelRect(x, y, 4, 4);
                    drawPixelRect(x + 10, y + 8, 2, 3);
                }
            }

            ctx.fillStyle = '#32CD32';
            ctx.fillRect(0, groundLevel - 6, canvas.width, 6);

            ctx.fillStyle = '#228B22';
            for (let i = 0; i < canvas.width; i += 3) {
                const grassHeight = 2 + Math.sin(i * 0.2) * 1;
                drawPixelRect(i, groundLevel - grassHeight - 3, 1, grassHeight);
            }

            holes.forEach(hole => {
                ctx.fillStyle = '#8B4513';
                drawPixelCircle(hole.x, hole.y - 6, 10);

                ctx.fillStyle = '#2F1B14';
                for (let dx = -8; dx <= 8; dx++) {
                    for (let dy = -3; dy <= 8; dy++) {
                        if (dx * dx + dy * dy <= 64 && hole.y + dy >= groundLevel) {
                            drawPixelRect(hole.x + dx, hole.y + dy, 1, 1);
                        }
                    }
                }

                ctx.fillStyle = '#1A1A1A';
                for (let dx = -5; dx <= 5; dx++) {
                    for (let dy = -2; dy <= 5; dy++) {
                        if (dx * dx + dy * dy <= 25 && hole.y + dy >= groundLevel) {
                            drawPixelRect(hole.x + dx, hole.y + dy, 1, 1);
                        }
                    }
                }
            });
        }

        function drawTurnip() {
            if (gameState.showStartButton) return;

            ctx.save();
            ctx.translate(turnip.x, turnip.y);

            if (turnip.isWalking) {
                ctx.translate(0, Math.sin(turnip.walkFrame) * 1.5);
            }

            const legOffset = turnip.isWalking ? Math.sin(turnip.walkFrame) * 6 : 0;
            const legOffset2 = turnip.isWalking ? Math.sin(turnip.walkFrame + Math.PI) * 6 : 0;

            ctx.fillStyle = '#2F4F4F';
            drawPixelRect(-9, 22 + legOffset, 8, 27);
            drawPixelRect(3, 22 + legOffset2, 8, 27);

            ctx.fillStyle = '#8B4513';
            drawPixelRect(-12, 46 + legOffset, 14, 6);
            drawPixelRect(0, 46 + legOffset2, 14, 6);

            if (turnip.isWalking) {
                ctx.translate(Math.sin(turnip.walkFrame * 0.5) * 1.5, 0);
            }

            ctx.fillStyle = '#FF0000';
            drawPixelRect(-12, -8, 24, 30);

            ctx.fillStyle = '#FFB347';
            drawPixelCircle(0, -22, 15);

            ctx.fillStyle = '#32CD32';
            const leafDirection = turnip.direction * 0.3;
            const baseTime = gameState.time * 0.03;

            ctx.save();
            ctx.translate(-12, -30);
            ctx.rotate(Math.sin(baseTime) * 0.15 - 0.2 + leafDirection);
            drawPixelRect(-3, -21, 6, 8);
            drawPixelRect(-5, -15, 10, 6);
            drawPixelRect(-4, -10, 8, 8);
            drawPixelRect(-2, -4, 4, 6);
            ctx.restore();

            ctx.save();
            ctx.translate(-6, -37);
            ctx.rotate(Math.sin(baseTime + 0.5) * 0.1 - 0.1 + leafDirection);
            drawPixelRect(-4, -24, 8, 10);
            drawPixelRect(-6, -16, 12, 8);
            drawPixelRect(-5, -10, 10, 8);
            drawPixelRect(-3, -4, 6, 6);
            ctx.restore();

            ctx.save();
            ctx.translate(0, -42);
            ctx.rotate(Math.sin(baseTime + 1) * 0.08 + leafDirection * 0.5);
            drawPixelRect(-6, -27, 12, 12);
            drawPixelRect(-8, -18, 16, 10);
            drawPixelRect(-7, -10, 14, 10);
            drawPixelRect(-4, -2, 8, 6);
            ctx.restore();

            ctx.save();
            ctx.translate(6, -37);
            ctx.rotate(Math.sin(baseTime + 1.5) * 0.1 + 0.1 - leafDirection);
            drawPixelRect(-4, -24, 8, 10);
            drawPixelRect(-6, -16, 12, 8);
            drawPixelRect(-5, -10, 10, 8);
            drawPixelRect(-3, -4, 6, 6);
            ctx.restore();

            ctx.save();
            ctx.translate(12, -30);
            ctx.rotate(Math.sin(baseTime + 2) * 0.15 + 0.2 - leafDirection);
            drawPixelRect(-3, -21, 6, 8);
            drawPixelRect(-5, -15, 10, 6);
            drawPixelRect(-4, -10, 8, 8);
            drawPixelRect(-2, -4, 4, 6);
            ctx.restore();

            ctx.fillStyle = '#708090';
            for (let y = -30; y < -8; y++) {
                for (let x = 0; x < 15; x++) {
                    const centerY = -19;
                    const distance = Math.sqrt(x * x + (y - centerY) * (y - centerY));
                    if (distance <= 15) {
                        drawPixelRect(x, y, 1, 1);
                    }
                }
            }

            ctx.fillStyle = '#FF0000';
            drawPixelRect(6, -27, 6, 6);
            ctx.fillStyle = '#FFFF00';
            drawPixelRect(7, -25, 3, 3);

            ctx.fillStyle = 'white';
            drawPixelRect(-9, -27, 6, 6);
            ctx.fillStyle = 'black';
            drawPixelRect(-7, -25, 3, 3);

            ctx.fillStyle = 'black';
            drawPixelRect(-6, -12, 6, 3);

            const armOffset = turnip.isWalking ? Math.sin(turnip.walkFrame) * 3 : 0;
            ctx.fillStyle = '#FFB347';
            drawPixelRect(-22, -3 + armOffset, 9, 18);
            drawPixelRect(-25, 12 + armOffset, 6, 9);

            ctx.fillStyle = '#FFB347';
            drawPixelRect(15, -22, 9, 18);

            ctx.fillStyle = '#2F4F4F';
            drawPixelRect(19, -37, 6, 24);
            ctx.fillStyle = '#696969';
            drawPixelRect(21, -34, 3, 18);

            if (turnip.shootCooldown > 20) {
                ctx.fillStyle = '#FFD700';
                drawPixelRect(18, -40, 9, 4);
            }

            ctx.restore();
        }

        function drawGardenLeaves() {
            gardenLeaves.forEach(leaf => {
                if (leaf.exists) {
                    const windSway = Math.sin(leaf.windFrame) * 0.5;

                    ctx.save();
                    ctx.translate(leaf.x, leaf.y);

                    ctx.fillStyle = '#FFA726';
                    drawPixelCircle(0, 0, 12);

                    ctx.fillStyle = '#FF9800';
                    drawPixelCircle(0, 0, 10);

                    ctx.fillStyle = '#FFB74D';
                    drawPixelCircle(0, -2, 8);

                    ctx.fillStyle = '#FFCC80';
                    drawPixelRect(-3, -5, 4, 3);

                    ctx.fillStyle = '#E65100';
                    drawPixelRect(-1, 12, 3, 20);
                    drawPixelRect(0, 32, 1, 8);

                    ctx.fillStyle = '#D84315';
                    drawPixelRect(-2, 16, 1, 6);
                    drawPixelRect(3, 18, 1, 4);
                    drawPixelRect(-1, 24, 1, 3);
                    drawPixelRect(2, 26, 1, 4);

                    ctx.fillStyle = '#2E7D32';
                    drawPixelRect(-2, -16, 4, 6);

                    ctx.save();
                    ctx.translate(windSway, 0);

                    ctx.fillStyle = '#4CAF50';
                    drawPixelRect(-10, -25, 20, 8);
                    drawPixelRect(-8, -30, 16, 6);
                    drawPixelRect(-12, -22, 24, 6);

                    ctx.fillStyle = '#66BB6A';
                    drawPixelRect(-15, -20, 8, 12);
                    drawPixelRect(7, -20, 8, 12);
                    drawPixelRect(-6, -32, 12, 4);

                    ctx.fillStyle = '#2E7D32';
                    drawPixelRect(-1, -28, 2, 16);
                    drawPixelRect(-8, -24, 1, 8);
                    drawPixelRect(7, -24, 1, 8);

                    ctx.fillStyle = '#4CAF50';
                    for (let i = 0; i < 8; i++) {
                        if (i % 2 === 0) {
                            drawPixelRect(-10 + i * 3, -25 - (i % 3), 2, 2);
                        }
                    }

                    ctx.restore();
                    ctx.restore();
                }
            });
        }

        function drawBirds() {
            birds.forEach(bird => {
                ctx.save();
                ctx.translate(bird.x, bird.y);

                ctx.fillStyle = '#8B4513';
                drawPixelRect(-12, -4, 24, 8);
                drawPixelRect(-16, -2, 8, 4);

                const wingFlap = Math.sin(bird.wingFrame) * 8;
                if (bird.state === 'flying' || bird.state === 'escaping') {
                    ctx.fillStyle = '#654321';
                    drawPixelRect(-8, -8 + wingFlap, 16, 4);
                    drawPixelRect(-8, 4 - wingFlap, 16, 4);
                }

                ctx.fillStyle = '#654321';
                drawPixelRect(12, -2, 8, 4);

                ctx.fillStyle = '#FFA500';
                drawPixelRect(-20, 0, 4, 2);

                ctx.fillStyle = 'black';
                drawPixelRect(-14, -2, 2, 2);

                if (bird.state === 'landing' || bird.state === 'taking') {
                    ctx.fillStyle = '#FFA500';
                    drawPixelRect(-4, 6, 2, 6);
                    drawPixelRect(2, 6, 2, 6);
                }

                if (bird.hasLeaf && bird.hasWholeRoot) {
                    ctx.fillStyle = '#FFA726';
                    drawPixelCircle(0, 16, 12);

                    ctx.fillStyle = '#FF9800';
                    drawPixelCircle(0, 16, 10);

                    ctx.fillStyle = '#FFB74D';
                    drawPixelCircle(0, 14, 8);

                    ctx.fillStyle = '#FFCC80';
                    drawPixelRect(-3, 11, 4, 3);

                    ctx.fillStyle = '#4CAF50';
                    drawPixelRect(-10, -1, 20, 8);
                    drawPixelRect(-8, -6, 16, 6);
                }

                ctx.restore();
            });
        }

        function drawFallingLeaves() {
            fallingLeaves.forEach(leaf => {
                ctx.save();
                ctx.translate(leaf.x, leaf.y);
                ctx.rotate(leaf.rotation);

                const alpha = leaf.life / 60;

                if (leaf.isWholeRoot) {
                    ctx.fillStyle = `rgba(255, 179, 71, ${alpha})`;
                    drawPixelCircle(0, 0, 5);
                    ctx.fillStyle = `rgba(50, 205, 50, ${alpha})`;
                    drawPixelRect(-6, -6, 12, 6);
                }

                ctx.restore();
            });
        }

        function drawBullets() {
            bullets.forEach(bullet => {
                ctx.fillStyle = '#FFD700';
                drawPixelRect(bullet.x - 2, bullet.y - 2, 4, 4);
            });
        }

        function drawParticles() {
            particles.forEach(p => {
                const alpha = p.life / p.maxLife;
                ctx.fillStyle = p.color.replace(')', `, ${alpha})`).replace('hsl', 'hsla');
                drawPixelRect(p.x - 1, p.y - 1, 2, 2);
            });
        }

        function drawPixelRect(x, y, w, h) {
            ctx.fillRect(Math.floor(x), Math.floor(y), w, h);
        }

        function drawPixelCircle(x, y, radius) {
            for (let dx = -radius; dx <= radius; dx++) {
                for (let dy = -radius; dy <= radius; dy++) {
                    if (dx * dx + dy * dy <= radius * radius) {
                        drawPixelRect(x + dx, y + dy, 1, 1);
                    }
                }
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            drawSky();
            drawGround();
            drawGardenLeaves();
            drawFallingLeaves();
            drawParticles();
            drawTurnip();
            drawBullets();
            drawBirds();
            drawUI();

            if (gameState.showStartButton) {
                drawPixelText('НАЧАТЬ ИГРУ', 100, 510, '#FFB347', 2);
                drawPixelText('КАСАНИЕ ДЛЯ ДВИЖЕНИЯ', 50, 550, '#00FF41', 1);
                return;
            }

            if (gameState.gameRunning && !gameState.isPaused) {
                drawPauseButton();
            }

            if (gameState.isPaused) {
                drawPauseScreen();
            }

            if (!gameState.gameRunning && !gameState.showStartButton) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                drawPixelText('ОГОРОД РАЗГРАБЛЕН', 60, 450, '#FF0000', 2);
                drawPixelText('СЧЕТ: ' + gameState.score, 140, 520, '#00FF41', 1);
                drawPixelText('НАЧАТЬ СНОВА', 140, 610, '#FFB347', 1);
            }
        }

        function updateUI() {
            scoreElement.textContent = gameState.score;
            leavesElement.textContent = gameState.leavesLeft;
            document.getElementById('ui').style.display = 'none';
        }

        function drawUI() {
            if (gameState.showStartButton) return;

            drawPixelText('ЛИСТЬЯ: ' + gameState.leavesLeft, 10, 20, '#FFB347', 2);
            drawPixelText('СЧЕТ: ' + gameState.score, 10, 50, '#FFB347', 2);
        }

        function gameLoop(currentTime) {
            // Оптимизация для высоких герц экранов
            if (!lastTime) lastTime = currentTime;
            deltaTime = currentTime - lastTime;
            
            // Обновляем игру только при достижении целевого FPS
            if (deltaTime >= FRAME_TIME) {
                update();
                draw();
                lastTime = currentTime - (deltaTime % FRAME_TIME);
            }
            
            requestAnimationFrame(gameLoop);
        }

        updateUI();
        gameLoop(0);
    </script>
</body>
</html>
